				GraphQL
.....................................................................................

What is GraphQL?
	GraphQL is a "new API" standard that provides a more efficient, powerful and flexible alternative to REST.

API:
 Appliation programming interface : Entry and exit point for data access.

How apis are represented /encapsulated?
 inside objects

Types of apis:
 1.local api
	api which is part of single runtime- jvm
 2.remote api
       rpc
	 -webservices -  rest api,soap api
         -rpi - grpc
         -tcp based apps
         -smtp based app
       etc...

REST:
   REST has not been designed to be user centric rather than data centric...

if you define any api, which returns data set eg: if you query an api called products

products may have so many fields, i dont want all fields which exposed by the api...

GET  /api/products

 =>[{
  ...
 }]

At its core, GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API.

Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.

GraphQL - A Query Language for APIs
Most applications today have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.

GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense it’s database agnostic and effectively can be used in any context where an API is used.
GraphQL - A Query Language for APIs
Most applications today have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.

GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense it’s database agnostic and effectively can be used in any context where an API is used.


A more efficient Alternative to REST
....................................

REST has been a popular way to expose data from a server. When the concept of REST was developed, client applications were relatively simple and the development pace wasn’t nearly where it is today. REST thus was a good fit for many applications. However, the API landscape has radically changed over the last couple of years. In particular, there are three factors that have been challenging the way APIs are designed:

1. Increased mobile usage creates need for efficient data loading
Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions.

2. Variety of different frontend frameworks and platforms
The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs.

3. Fast development & expectation for rapid feature development
Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations.

1. Increased mobile usage creates need for efficient data loading
Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions.

2. Variety of different frontend frameworks and platforms
The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs.

3. Fast development & expectation for rapid feature development
Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations.
.....................................................................................
			  How to begin with GraphQL


GraphQL is platform and language independant.

GraphQL Can be classified into two category

1.Client side - How to send data(Request) to the GraphQL server.
  in order to send data from the client face book published one spec

called
   "GraphQL Query language spec"

2.Server side - How to build graph(object tree) from the data sources
    "GraphQL Schema language spec"

.....................................................................................
			  GraphQL request and response model.


Declarative Programming:

What you write, you have to get the same structure.

The Query request is more readable,declarative. WHich micics the javascript object literal syntax.

js object:

 let user =  {
     id:1,
     name:'joe'
     friends: [
        'bar','foo'
     ]
  } 

GraphQL Request payload : GraphQL Query
.......................................

GraphQL Client 
POST /endpoint

  {
     id
     name
     friends { -----------------------------> GraphQLServer
        name
     }
  } 

Response:JSON
 {
     "id":1,
     "name":"joe"
     "friends": [      <----------------------------- GraphQLServer
        "bar","foo"
     ]
  } 

..............................................................................................
				 REST AND CURD

Operations Type

GET ------Read
POST -----CREATE
PUT ------UPDATE
DELETE----Remove
.............................................................................................
				GRAPHQL And CURD


GraphQL uses only URL which exposes Service


  {
     id
     name
     friends { -----------HTTP POST------------------> GraphQLServer
        name
     }
  } 

Operation Types:

1.Query
  read
2.mutation
  create,update,delete
3.subscription
   Streaming

query - a read only fetch
mutation- a write followed by read
subscription- a long live request that fetches data in response to source events
..................................................................................
.....................................................................................
				Schema Query Language -spec
....................................................................................

1.selection set

 selectionSet : { Selection }

selectionSet could be "query,mutation,subscription"

Selection:
 -fields
 -Fragement Spread
 -lnline fragement.

fields:
query { 
   person {
    firstname
    lastname
   }
}

Selection set to be selected by somebody(Operation)

An Operation selects the set of information it needs, exactly will receive that information

Operation and Selection Set

query {
 firstname
  lastname
  age
}
mutation createUser(params){
  user
}
subscription getPriceQuote(params) {
 price
 name
}
.....................................................................................

Here we use demo graphql api in order  to learn "GraphQL Query language spec"

Concepts:
 => fields
 => arguments
 => aliases
 => fragements
 => variables
 => directives
 => Mutations
 => inline fragments

Tool to test graphql end points:
1.client tool - playground
https://www.graphqlbin.com/v2/new

2.demo api
https://countries.trevorblades.com/

Fields:
Demo graphql end points:
.........................
https://www.graphqlbin.com/v2/new
url:
https://countries.trevorblades.com/


Fields: 
........
At its simplest, GraphQL is about asking for specific fields on objects. 
Let's start by looking at a very simple query and the result we get when we run it:

Are properties of an object.

eg:

query {
   countries {
     name
  }
}

short cut:
{
   countries {
     name
  }
}

Response:
{
  "data": {
    "countries": [
      {
        "name": "Andorra"
      },
      {
        "name": "United Arab Emirates"
      },
      {
        "name": "Afghanistan"
      }
}
...
More fields:
 How do we know that the api has more fields?
 In the playground , we can see docs.by looking docs we can come to know the fields

{
  countries {
    code
    name
    native
    capital
    currency
  }
}

Response
{
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra",
        "native": "Andorra",
        "capital": "Andorra la Vella",
        "currency": "EUR"
      },
      {
        "code": "AE",
        "name": "United Arab Emirates",
        "native": "دولة الإمارات العربية المتحدة",
        "capital": "Abu Dhabi",
        "currency": "AED"
      },
}
...

How to query nested values?

query getAllCountries {
  countries {
    code
    name
    capital
    continent {
      name
    }
    states {
      name
    }
  }
}


Response:

{
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra",
        "native": "Andorra",
        "capital": "Andorra la Vella",
        "currency": "EUR",
        "states": []
      },
  "states": [
          {
            "name": "Ciudad Autónoma de Buenos Aires"
          },
          {
            "name": "Buenos Aires"
          },
          {
            "name": "Catamarca"
          },
          {
            "name": "Chaco"
          }
]
}
.....................................................................................
			   Arguments

What if i want to get data based on some condition or conditions...

Syntax:
{
  human(id: "1000") {
    name
    height
  }
}
Here we query data for human having id 1000 such as name , height.

Arguments can be static arg or dynamic arg:
...........................................

Static arg means passing hardcoded values.

query {
  country(code: "US") {
    name    
  }
  continent(code:"AS"){
    name
  }
}

Response:
{
  "data": {
    "country": {
      "name": "United States"
    },
    "continent": {
      "name": "Asia"
    }
  }
}
.....................................................................................
			  Dynamic Parameters/Arugments -Variables
.....................................................................................
Variables:
 variables are place holders to have dynamic values.
 in case of client apps, you may select values from dropdrown,or from text field

Variables are introduced in graphql via $variableName

Steps:
1.replace static values in the query with $variableVariable
2.Declare the variable ($variableName) as part of the query header

Synax:

query queryHeader($variableName:Type) {
   api(variable:$variableName) {
    fields
   }
}
eg:
query getCountryById($code:ID!) {
  country(code: $code) {
    name
  }
}

Passing variables via Query variables in PlayGround
{
  "code": "US"
}
Response:
{
  "data": {
    "country": {
      "name": "United States"
    }
  }
}

Parameter/arg types:
...................
1.can be primtives(scalar types)-ID,String,Int,Float....
2.can be complex Types - Object types

.....................................................................................
Complex types

eg:
query getLanguageInfo($filter: LanguageFilterInput) {
  languages(filter: $filter) {
    code
    name
    native
    rtl
  }
}

Input:
{
  "filter": {
    "code": {
      "eq": "en" 
    }
  }
}
Response:
{
  "data": {
    "languages": [
      {
        "code": "en",
        "name": "English",
        "native": "English",
        "rtl": false
      }
    ]
  }
}
.....................................................................................
			Argument Default Values
....................................................................................

Some times if we dont want to pass values to the api explicitly..

Syntax:
.......

query getProfile($id:Int){
    user(id:$id) {
      name
      pic
    }
  }
}

How to pass variable 
{"id" : 5 }
{"id" : 6 }

Variable default Value

query getProfile($id:Int=2){
    user(id:$id){
      name
      pic
    }
  }
}
more variables
query getProfile($id:Int,$withFriends:Boolean=false){
    user(id:$id,withFriends:$withFriends) {
      name
      pic  
    }
  }
}
{"id" : 5 ,"withFriends":true}
{"id" : 5}

eg:

query getCountryByCode($code: ID = "US") {
  country(code: $code) {
    code
    name
    native
    phone
    continent {
      code
      name
    }
    capital
   
  }
}


Variables:
with parameters
{
  "code": "IN"
}

Response:
{
  "data": {
    "country": {
      "code": "IN",
      "name": "India",
      "native": "भारत",
      "phone": "91",
      "continent": {
        "code": "AS",
        "name": "Asia"
      },
      "capital": "New Delhi"
    }
  }
}
without parameters

Response:
{
  "data": {
    "country": {
      "code": "US",
      "name": "United States",
      "native": "United States",
      "phone": "1",
      "continent": {
        "code": "NA",
        "name": "North America"
      },
      "capital": "Washington D.C."
    }
  }
}
............................******************......................................
				 Aliases

Field alisases gives a dummy name for keys...

Syntax:
Without aliases:

{ 

 user(id:1) {
    id
    name
 }

}

{
  "data": {
    "user" : {
      "id" :1
      "name": "Subramaian"
    }
  }
}

{ 

 subu:user(id:1) {
    id
    name
 }

}
With aliases:
{
  "data": {
    "subu" : {
      "id" :1
      "name": "Subramaian"
    }
  }
}

eg:
query getCountryByCode($code: ID = "US") {
  mycountry:country(code: $code) {
    code
    myName:name
    native
    phone
    mycontient:continent {
      code
      name
    }
    capital   
  }
}

Response:
{
  "data": {
    "mycountry": {
      "code": "US",
      "myName": "United States",
      "native": "United States",
      "phone": "1",
      "mycontient": {
        "code": "NA",
        "name": "North America"
      },
      "capital": "Washington D.C."
    }
  }
}
.....................................................................................
			    Fragments: Resuable SelectionSet
....................................................................................

What if i have some fields , duplicated in many query apis , where fragments are used.

Sytnax:
Without Fragment:
.................

{
 user(id:4) {

  friends {
    id
    name
    pic
  }
  mutualfriends {
    id
    name
    pic
  }
 }

}
With Fragment:
.................

{
  user(id:4) {

  friends {
    ...friendsFields
  }
  mutualfriends {
   ...friendsFields
  }
 }

}
fragement friendsFields on User {
  id
  name
  pic
}

eg:
query getA1AndA2Countries {
  a1countries: countries {
    ...countryinfo
  }
  a2countries: countries {
    ...countryinfo
  }
}
fragment countryinfo on Country {
  name
  capital
}
Response:
{
  "data": {
    "a1countries": [
      {
        "name": "Andorra",
        "capital": "Andorra la Vella"
      },
      {
        "name": "United Arab Emirates",
        "capital": "Abu Dhabi"
      },
"a2countries": [
      {
        "name": "Andorra",
        "capital": "Andorra la Vella"
      },
      {
        "name": "United Arab Emirates",
        "capital": "Abu Dhabi"
      }
}
.....................................................................................
			   Directives
.....................................................................................
Directives are built in functions which provides some utilties

@include(if:Boolean)
  Only include  "this field" in the result if the argument is true
@skip(if:Boolean)
  Skip this field if the argument is true

Syntax:
{
  getProfile($id:Int,$withFriends:Boolean=false){
    user {
      name
      pic  
      friends @include(if:$withFriends)   {
	name
      }
    }
  }
}
{"id" : 5 ,"withFriends":true}

eg:
query($code: ID!, $rtl: Boolean!) {
  language(code: $code) {
    name
    native @include(if: $rtl) 
  }
}

input:
{
  "code": "en","rtl": false 
}

Response:
{
  "data": {
    "language": {
      "name": "English"
    }
  }
}
input:
{
  "code": "en","rtl": true
}

Response 
{
  "data": {
    "language": {
      "name": "English",
      "native": "English"
    }
  }
}
.....................................................................................
			 Mutations
....................................................................................
How to send Payload for create(insert),update,remove?

In REST
POST => CREATE
PUT => UPDATE
DELETE=REMOVE

Read Data(Query)
query getCountryByCode($id:ID) {
   country(code: $code) {
    code
    myName:name
   }
}
//Mutations: 
mutation CreateCountry($country:Country) {
   //api
   createCountry(country:$country){
      //response field
     code
     name
   }
}

Response:
 {
  "code":"XXX"
  "name":"YYY"
}
....................................................................................
				Meta Fields

..................................................................................

Apart from , fields returned by GraphQl server, some built in fields called meta fields are also returned by server.

__typename : Returns the data Type of Object returned

query {
  countries {
    __typename
    name,
    states
    {
      __typename
      name
    }
  }
}
Response:
{
  "data": {
    "countries": [
      {
        "__typename": "Country",
        "name": "Andorra",
        "states": []
      },
}
.....................................................................................
	GraphQL - Server Side : GraphQL Schema language spec and implementation
...................................................................................

How to build rest applications?
 Restfull web services are built based on "resources" in the problem domain.
Resource represents a Object which expose data 
eg: CustomerResource,OrderResource,ProductResource
Resources are identified by URL /api/customers and Method "GET | POST | PUT |DELETE "
	
How to build graphql applications?
 
Graphql apps are built based on Objects called "Models".

What ever lanaugage we have to think in terms of Objects.

Object shape is described by "schema".

Schema is nothing but plan /design.

Schema represents the Object design

In Graphql The design is represented by "GraphQL schema Lanaguage"
.....................................................................................
			  SDL - Schema definition language
.....................................................................................

SDL Core concepts:

1.Type System:
   The Type system defines the Platform indenpendent data types and variable which describe what data can be queired by client.

query getUserData {
 
   user {
	name             =>SDL=>|SDL|===>Enity==>Biz logic(Services)====>DataSources
   }

}

Both Servers and clients talks via common language called SDL...

SDL provides language independant abstraction
				 
				|---- Java/Kotlin/scala --Jvm
			SDL-----|-----js/ts ----node


syntax:
type TypeName {
   field:DataType
}
In SDL , there is root type , every type is dervied from the root type

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}

######
type Query{
 #api
 greet:String
 name:String
}
SDL Defines its language and platform independant data types:
.............................................................
1.Scallar types
2.Custom Types/ReferenceTypes/Object Types


1.Scallar Types:
  Scallars are like primitive types in your language

1.Int -32 bit signed integer
2.String - UTF-8 char Sequence
3.Boolean - true or false
4.Float - singed double 
5.ID (Serialized String)- A unique identifier


2.Object Type/Complex/User Defined/Reference Type
 Similar to classes in object oriented languages- like java,C#

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean  
}

Object Type can have other Object Type :
  Like has a relationship/ Dependency injection

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}
....................................................................................
			  Handling null and not null values
...................................................................................

Client Query With data
{
  name  --------> response {name:"subramanian"}
}

Client Query Without data
{
  name  --------> response {name:null}
}

I dont want null value for a given field? How to force the field must have data or must not have null?
 => not null fields

syntax:
 fieldName:Type!
!(not null)

type Address {
  city:String
  state:String
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}
...................................................................................
			  Collection - List of Similar Values
..................................................................................

The field may have more values
 fieldName:[DataType]
  DataType here can be Scalar or Object type
 eg:
 fieldName:[String] | [Int] [Float]
 fieldName:[Address] [Order] [Items]

Collection can also be not null
 fieldName:[Address]! [Order]! [Items]!


type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}
.....................................................................................
			 Query Type
.....................................................................................

Query is collection of apis
An api can return and accept values

No Parameter,Only Return
  field:Type

type Query {
 name:String  
 user:User
 users:[User]
}
Parameter,And Return Return
  field:Type

type Query {
  hello(name:String,message:String):String
  users:[User]
  userById(id:ID):[User]
}
...................................................................................
			    Advanced Types

=>Mutation 
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
  The Mutation is similar in Strcuture and purpose to the Query Type.

Where as Query is read only operations, where as "Mutation" is entry points for "Write and Read" operations

Signature of the Mutation:
.........................

type Mutation {
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
   updateUser(id:ID,user:User):User
   removeUser(id:ID):User
}
....................................................................................
			  Input Types
...................................................................................

Input types are special Object types that allow you to provide hierarchical data as arguments to fields( as apposed to providing only flat scalar arguments

type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}

type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserInput { 
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserResponse {
  id:ID
  firstName:String
  lastName:String
}

//Mutation with inputType
type Mutation {
   #Using Input Type
   createUser(userInput:UserInput):UserResponse
}
....................................................................................
				Enums
....................................................................................

An Enum is similar to scalar type, but its legal values are defined in the schema.

enum Gender {
 MALE
 FEMALE
 THIRD
}
How to use Enum?

type Query {
  gender:Gender
}
.....................................................................................
			  Union and Interfaces
...................................................................................

Unions and interfaces abstract GraphQL types that enables a schema field to return one of multiple object types.

union  Media= Image | Video

type Query {
 # This list can include both Image and Video Objects
 getMedia:[Media] 
}

Note:
  Union types must be only Object types not scalars or input types.
....................................................................................
			 Interface

Interface represents common fields that multiple objects can include.

interface Book {
 title:String!
 author:String!
}

type TechnicalBook implements Book {
 title:String!
 author:String!
 X:String
}

type StoryBook {
 title:String!
 author:String!
 Y:String
}

Query:
type Query {
  books:[Book]
}

Client Side: How to Query data Based on Interface

Syntax: 1 
query GetBooks{
  books {
   author
   title
  }
}

Here it returns all data ,

What if i want Technical and story book details with clear values

query GetBooks{

 books {
 
   __typename
   title
   ... on TechnicalBook {
      X
   }
   ... on StoryBook {
     Y
   }
 }

}
.....................................................................................
			 Custom Scalar
.....................................................................................
GraphQL SDL provides basic core scalars - Int,String,Boolean,ID,Float.
What if i want other data types like Date,Time


How to define custom scalar

scalar  Date

type User {
 dob:Date
}

Here Date is custom Scalar, but how this data type is represented /logic of this type is provided through "Server side"
.....................................................................................
				GraphQL Application Dev
.....................................................................................

Req: 
  SDL must be there and must be very clear.

GraphQL Application can be written in any language

Javascript Implementation (Runtime is Node.js)
................................................

1.graphql.js
  =>Core framework written by face book
  =>you can run standalone or on top of webserver/(container)
  =>Express.js is underlaying framework...

2.Apollo
   =>It is a platform for building graphql apps called supergraph
   =>Apollo is wrapper on the top of express server with microservice development

Components of Apllo (GraphQl app)

1.Apollo Server
2.Schema Definitions
3.Resolvers-Schema implemnetation
4.DataSources


Getting started With Project setup:

Typescript With Apollo:
........................

Here we create basic project structure:

E:\session\TechMahendra>mkdir apollo-gettingstarted

E:\session\TechMahendra>cd  apollo-gettingstarted

E:\session\TechMahendra\apollo-gettingstarted>npm init --yes

E:\session\TechMahendra\apollo-gettingstarted>code .

E:\session\TechMahendra\apollo-gettingstarted>mkdir src

install dependencies:
 npm i @apollo/server graphql 

Type script dependencies:
 npm i --save-dev typescript @types/node

package.json
  "dependencies": {
    "@apollo/server": "^4.3.0",
    "graphql": "^16.6.0"
  },
  "devDependencies": {
    "@types/node": "^18.11.18",
    "typescript": "^4.9.4"
  }

create ts config file:
tsconfig.json
{
    "compilerOptions": {
      "rootDirs": ["src"],
      "outDir": "dist",
      "lib": ["es2020"],
      "target": "es2020",
      "module": "esnext",
      "moduleResolution": "node",
      "esModuleInterop": true,
      "types": ["node"]
    }
  }

script configuration:
package.json
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js"
  },

write code inside src/index.ts
console.log('welcome to apollo')


E:\session\TechMahendra\apollo-gettingstarted>npm start

> apollo-gettingstarted@1.0.0 start
> npm run compile && node ./dist/index.js


> apollo-gettingstarted@1.0.0 compile
> tsc

welcome to apollo
.....................................................................................
				

Steps:
1.Define schema
2.Write logic - Resolver
3.start Apollo Server


Define Schema:

Schema definition is represented as "plain String".

Steps:
1.Define Schema
src/index.ts

//Define Schema

//Define Schema
const typeDefs = `
#Simple Query:Which returns helloworld
type Query {
  hello:String
}

`
//
2.Biz logic : We need to write implementation for Query :Resolver


src/index.ts
//Define Schema
const typeDefs = `
#Simple Query:Which returns helloworld
type Query {
  hello:String
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        hello() {
            return "Hello,Apollo GraphQL"
        }
    }
    //Mutation

    //Subscription
}


3.We need to deploy(parse schema,bind resolvers....)
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

3.1.We need to create instance of ApolloServer and pass schema and resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

3.2.Start web Container and deploy

//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
.....................................................................................
Final Code:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
#Simple Query:Which returns helloworld
type Query {
  hello:String
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        hello() {
            return "Hello,Apollo GraphQL"
        }
    }
    //Mutation

    //Subscription
}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)


How to test?
http://localhost:4000/

query {
  hello
}

Response:
{
  "data": {
    "hello": "Hello,Apollo GraphQL"
  }
}
.....................................................................................
				Descriptions(docStrings)
.....................................................................................

GraphQl schema definition supports markdown enabled documentation strings called "descriptions" . This helps consumers of your graph discover fields and learn how to use them.

""comments"" =>single line comment
"""       =>multi line comments

""
eg:
src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
#Simple Query:Which returns helloworld

type Query {
    """
     This is hello api which returns hello world in 
     in the string format.
    """
  hello:String
  "This is hai api which returns hai messsage"
  hai:String
  
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        hello() {
            return "Hello,Apollo GraphQL"
        },
        hai() {
            return "Hai , GraphQL!"
        }
    }
    //Mutation

    //Subscription
}
// const server = new ApolloServer({
//     typeDefs: typeDefs,
//     resolvers: resolvers
// })
const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
....................................................................................
			  Default Resolver

if you define query, if you dont define resolver, the Apollo by default provides default resolver which always returns "null".

src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type Query {
    hello:String
  }

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
      
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
query {
  hello
}
Response:
{
  "data": {
    "hello": null
  }
}
..................................................................................
			      Object Type and Queries
...................................................................................

src/index.ts

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
  }
  #Query for User
  type Query {
    user:User
  }

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        user() {
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 42,
                points: 200.5,
                status: true
            }
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:

query {
  user {
    id
    firstName
    lastName
    points
    status
  }
}
Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "points": 200.5,
      "status": true
    }
  }
}
....................................................................................
			 Collections

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
  }
  #Query for User
  type Query {
    users:[User]
  }

`
////
//Mock data
const USERS = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 42,
    points: 200.5,
    status: true

},
{
    id: 2,
    firstName: 'Ram',
    lastName: 'Murugan',
    age: 35,
    points: 100.5,
    status: true

},
{
    id: 3,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 38,
    points: 500.5,
    status: false

},
{
    id: 4,
    firstName: 'John',
    lastName: 'Mc',
    age: 23,
    points: 200.5,
    status: false

},
{
    id: 5,
    firstName: 'Karthik',
    lastName: 'Subramanian',
    age: 22,
    points: 500.5,
    status: true

}
]



//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS 
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
query {
  users {
    id
    firstName
    lastName
    points
    status
  }
}
Response:

{
  "data": {
    "users": [
      {
        "id": "1",
        "firstName": "Subramanian",
        "lastName": "Murugan",
        "points": 200.5,
        "status": true
      },
      {
        "id": "2",
        "firstName": "Ram",
        "lastName": "Murugan",
        "points": 100.5,
        "status": true
      },
      {
        "id": "3",
        "firstName": "Geetha",
        "lastName": "Subramanian",
        "points": 500.5,
        "status": false
      },
      {
        "id": "4",
        "firstName": "John",
        "lastName": "Mc",
        "points": 200.5,
        "status": false
      },
      {
        "id": "5",
        "firstName": "Karthik",
        "lastName": "Subramanian",
        "points": 500.5,
        "status": true
      }
    ]
  }
}
.....................................................................................
			 Handle Args and parameters
.....................................................................................
How to handle args/parameters?
 A Resolver function takes four positional optional args
 
fun(parent,args,contextValue,info){


}
args it is variable going to hold parameters passed by clients.
args value is going to be literal object.
How many parameters you pass , all parameters are stored inside single literal object

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
type Query {
  hello(name:String):String
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        hello(parent, args, contextValue, info) {
            console.log(args)
            return `Hello ${args.name}`
        }
    }

}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)


Request: Static Parameters:
query {
  hello(name: "Ram")
}

Response:
{
  "data": {
    "hello": "Hello Ram"
  }
}
Request:Dynamic Parameters
query getName($name:String) {
  hello(name:$name)
}
Variable
{
  "name":"Ram"
}
{
  "data": {
    "hello": "Hello Ram"
  }
}
.....................................................................................
			  Handling Complex args and parameters

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
  }
  #Query for User
  type Query {
    users:[User]
    user(id:ID!):User
  }

`
////
//Mock data
const USERS = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 42,
    points: 200.5,
    status: true

},
{
    id: 2,
    firstName: 'Ram',
    lastName: 'Murugan',
    age: 35,
    points: 100.5,
    status: true

},
{
    id: 3,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 38,
    points: 500.5,
    status: false

},
{
    id: 4,
    firstName: 'John',
    lastName: 'Mc',
    age: 23,
    points: 200.5,
    status: false

},
{
    id: 5,
    firstName: 'Karthik',
    lastName: 'Subramanian',
    age: 22,
    points: 500.5,
    status: true

}
]



//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        },
        user(_, args) {
            const { id } = args; //destructure args object:Extract id field
            //biz logic
            return USERS.find(user => {
                return user.id === +id
            })
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
query getuserById($id:ID!){
    user(id:$id) {
      id
      firstName
      lastName
    }
}
Response:
{
  "data": {
    "user": {
      "id": "5",
      "firstName": "Karthik",
      "lastName": "Subramanian"
    }
  }
}
if parameter does not match: it returns null
{
  "data": {
    "user": null
  }
}
....................................................................................

Coding Challange:
users : [

const  users = [
 {id:1,name:'a',email:'a@gmail.com',address: {
   city:'a',state:'b'
 }
}
]

src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID!
    name:String
    email:String
    address:Address
  }
  type Address {
    city:String
    state:String
  }
  #Query for User
  type Query {
    users:[User]   
  }

`
//USERS ARRAY THINK AS Database table:
//CREATE TABLE users(id int,name varchar(20),email varchar(30),constraint c primaryKey(id))
//CREATE TABLE address(city varchar(20),state varchar(30), id int references users id)
//How to link a user with his/her address when you query.
// a info with address

//DECLARE USERS information in array like tables

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]


const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2
},
{
    city: 'HYD',
    state: 'TS',
    id: 3
}
]

//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)


When you run the above code,with the below query

query {
   users {
     id
     name
     email
     address {
       city
       state
     }
   }
}

You will get Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": null
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": null
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": null
      }
    ]
  }
}
Here address is missing, that means address is part of schema but not part of resolver.

How to link users with address?
.....................................................................................
			    Resolver Chains
....................................................................................

Resolver chains means coimbing results of one resolver with in nested resolver..


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID!
    name:String
    email:String
    address:Address #This becomes Query
  }
  type Address {
    city:String
    state:String
  }
  #Query for User
  type Query {
    users:[User]   
  }

`
//USERS ARRAY THINK AS Database table:
//CREATE TABLE users(id int,name varchar(20),email varchar(30),constraint c primaryKey(id))
//CREATE TABLE address(city varchar(20),state varchar(30), id int references users id)
//How to link a user with his/her address when you query.
// a info with address

//DECLARE USERS information in array like tables

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]


const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2
},
{
    city: 'HYD',
    state: 'TS',
    id: 3
}
]

//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            //return address
            //Get the Parent of Address
            return ADDRESS.find(address => {
                return address.id === parent.id
            })
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
query {
   users {
     id
     name
     email
     address {
       city
       state 
       
     }
   }
}
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": {
          "city": "CBE",
          "state": "TN"
        }
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": {
          "city": "BNG",
          "state": "KA"
        }
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": {
          "city": "HYD",
          "state": "TS"
        }
      }
    ]
  }
}
....................................................................................
			Many to Many  - Many Users - Each User Many address
....................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
  type User {
    id:ID!
    name:String
    email:String
    address:[Address] #This becomes Query
  }
  type Address {
    city:String
    state:String
  }
  #Query for User
  type Query {
    users:[User]   
  }

`

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]


const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'CHN',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2
},
{
    city: 'CHN',
    state: 'TN',
    id: 2
},
{
    city: 'HYD',
    state: 'TS',
    id: 3
},
{
    city: 'CBE',
    state: 'TN',
    id: 3
}
]

//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            return ADDRESS.filter(address => {
                return address.id === parent.id
            })
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:

query {
   users {
     id
     name
     email
     address {
       city
       state 
       
     }
   }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": [
          {
            "city": "CBE",
            "state": "TN"
          },
          {
            "city": "CHN",
            "state": "TN"
          }
        ]
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": [
          {
            "city": "BNG",
            "state": "KA"
          },
          {
            "city": "CHN",
            "state": "TN"
          }
        ]
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": [
          {
            "city": "HYD",
            "state": "TS"
          },
          {
            "city": "CBE",
            "state": "TN"
          }
        ]
      }
    ]
  }
}
.....................................................................................
			  Many - Many -Parametermized
.....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"
import { userInfo } from "os"

//Define Schema
const typeDefs = `
  type User {
    id:ID!
    name:String
    email:String
    address:[Address] #This becomes Query
  }
  type Address {
    city:String
    state:String
  }
  #Query for User
  type Query {
    users:[User] 
    user(id:ID):User
  }

`

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]


const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'CHN',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2
},
{
    city: 'CHN',
    state: 'TN',
    id: 2
},
{
    city: 'HYD',
    state: 'TS',
    id: 3
},
{
    city: 'CBE',
    state: 'TN',
    id: 3
}
]

//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        },
        user(_,args) {
            return USERS.find(user => {
                return user.id === +args.id
            })
        }

    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            return ADDRESS.filter(address => {
                return address.id === parent.id
            })
        }
    }
}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
query getUserById($userId: ID!) {
  user(id: $userId) {
    id
    name
    address {
      city
      state
    }
  }
}
Variable:
{
  "userId": "2"
}
Response:
{
  "data": {
    "user": {
      "id": "2",
      "name": "B",
      "address": [
        {
          "city": "BNG",
          "state": "KA"
        },
        {
          "city": "CHN",
          "state": "TN"
        }
      ]
    }
  }
}


Code Challange:

 Customer
    -[Orders]

 Query
  customers:[Customer]

Response:
  [ 
   {
    id:1,
    name:
    orders: [{id:1,value:12}]
   },
 {
    id:1,
    name:
    orders: [{id:1,value:12}]
   }
 ]
....................................................................................
				Mutations
.....................................................................................

How to send data for insert,update,remove.

type Mutation {
  //add apis
}

src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `

type User {
 id:ID!
 name:String
 email:String
}

type Query {
  users:[User]
  user(id:ID!):User
}

input UserInput{
    id:ID!
    name:String
    email:String
}

type AddUserMutationResponse {
    code:String!
    success:Boolean!
    message:String!
}

type Mutation {
   createUser(userInput:UserInput):AddUserMutationResponse
}
`

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]
//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        },
        user(_, args) {
            return USERS.find(user => user.id === +args.id)
        }
    },
    //Mutation
    Mutation: {
        //add new User
        createUser(_, args) {
            //call api to insert users
            USERS.push(args.userInput)
            console.log(args.userInput)
            return {
                code: '200',
                success: true,
                message: 'New User added!'
            }
        }
    }

}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
........
mutation ($userInput:UserInput) {
    createUser(userInput: $userInput) {
      code
      message
      success
    }
}

Variable:
{
  "userInput": {
    "id": "100",
    "name": "Foo",
    "email":"foo@gmail.com"
  }
}
Response:
{
  "data": {
    "createUser": {
      "code": "200",
      "message": "New User added!",
      "success": true
    }
  }
}

Coding Challange:
 You have to update User info
 You have to remove User Info
.....................................................................................
			  Union Types
.....................................................................................

How to resolve unions and interfaces?

 union Media = Book | Movie

 type Query {
   allMedia:[Media] # This includes Both Book and Movie Objects
 }

Syntax
query {
  ...on Book { }
  ...on Movie {} 
}

How Apollo server returns data based on Type?

  __resolveType function

    Media: {
        __resolveType(obj, contextValue, info) {
            if (obj.movietitle) {
                return 'Movie' // Type Name Must be String
            }
            if (obj.author) {
                return 'Book'
            }
            return null
        }
    },

eg:
src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
 #Product OutStock or Availablity or Product

 #Product Name is Candy
 type Candy{
   id:String!
   name:String!
   price:Float
 }
 #Status Types
 type OutOfStock {
    restockDate:String
 }
 type RegionUnAvailablity {
    availableRegions: [String!]
 }

 #union type
 union CandyResult = Candy | OutOfStock | RegionUnAvailablity

 type Query {
    candy(id:String!):CandyResult
 }

 `
//data
const CANDIES = [
    {
        "id": "gummy-bears",
        "name": "Haribo Gummy Bears",
        "price": 100.89
    },
    {
        "id": "sour-patch",
        "name": "Sour-Patch Kids",
        "price": 45.89
    },
    {
        "id": "wonka-nerds",
        "name": "Wonka Nerds",
        "restockDate": "2022-04-10"
    },
    {
        "id": "swirly-pops",
        "name": "Swirly Pops",
        "availableRegions": ["Coimbatore", "Chennai", "Banaglore"]
    }
]


//Define Resolver
const resolvers = {

    //Resolver Type Resolution function
    CandyResult: {
        __resolveType(obj, contextValue, info) {
            //we need to pass unquie fields
            if (obj.restockDate) {
                return 'OutOfStock' // Type Name Must be String
            }
            if (obj.availableRegions) {
                return 'RegionUnAvailablity'
            }
            if (obj.price) {
                return 'Candy'
            }
            return null
        }
    },

    //Query
    Query: {
        candy(_, args) {
            return CANDIES.find(candy => {
                return candy.id === args.id
            })
        }
    }

}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
.....................................................................................
				interface
.....................................................................................
An interface also provides program to super type approach similar to union type...
An interface provides a set of filelds that multiple objects types can include

type Query {
  myQuery:InterfaceType
}


  
	














   
